// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///===========================================================================
///ENUMS
///=============================================================================
enum PBCommon_Gender: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownGender // = 0
  case male // = 1
  case female // = 2
  case other // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownGender
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownGender
    case 1: self = .male
    case 2: self = .female
    case 3: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownGender: return 0
    case .male: return 1
    case .female: return 2
    case .other: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBCommon_Gender: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBCommon_Gender] = [
    .unknownGender,
    .male,
    .female,
    .other,
  ]
}

#endif  // swift(>=4.2)

enum PBCommon_ChatMessageType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownType // = 0
  case text // = 1
  case image // = 2
  case gif // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownType
    case 1: self = .text
    case 2: self = .image
    case 3: self = .gif
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownType: return 0
    case .text: return 1
    case .image: return 2
    case .gif: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBCommon_ChatMessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBCommon_ChatMessageType] = [
    .unknownType,
    .text,
    .image,
    .gif,
  ]
}

#endif  // swift(>=4.2)

enum PBCommon_UserDataField: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case fieldUserID // = 0
  case fieldName // = 1
  case fieldAge // = 2
  case fieldGender // = 3
  case fieldCityName // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .fieldUserID
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fieldUserID
    case 1: self = .fieldName
    case 2: self = .fieldAge
    case 3: self = .fieldGender
    case 4: self = .fieldCityName
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .fieldUserID: return 0
    case .fieldName: return 1
    case .fieldAge: return 2
    case .fieldGender: return 3
    case .fieldCityName: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBCommon_UserDataField: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBCommon_UserDataField] = [
    .fieldUserID,
    .fieldName,
    .fieldAge,
    .fieldGender,
    .fieldCityName,
  ]
}

#endif  // swift(>=4.2)

enum PBCommon_PrivateUserDataField: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// WORK
  case fieldPhoneNumber // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .fieldPhoneNumber
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fieldPhoneNumber
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .fieldPhoneNumber: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBCommon_PrivateUserDataField: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBCommon_PrivateUserDataField] = [
    .fieldPhoneNumber,
  ]
}

#endif  // swift(>=4.2)

enum PBCommon_ReturnReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authenticationNeeded // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .authenticationNeeded
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authenticationNeeded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authenticationNeeded: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PBCommon_ReturnReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PBCommon_ReturnReason] = [
    .authenticationNeeded,
  ]
}

#endif  // swift(>=4.2)

struct PBCommon_PBMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rowID: UInt32 {
    get {return _storage._rowID}
    set {_uniqueStorage()._rowID = newValue}
  }

  var errID: UInt32 {
    get {return _storage._errID ?? 0}
    set {_uniqueStorage()._errID = newValue}
  }
  /// Returns true if `errID` has been explicitly set.
  var hasErrID: Bool {return _storage._errID != nil}
  /// Clears the value of `errID`. Subsequent reads from it will return its default value.
  mutating func clearErrID() {_uniqueStorage()._errID = nil}

  var errStr: String {
    get {return _storage._errStr ?? String()}
    set {_uniqueStorage()._errStr = newValue}
  }
  /// Returns true if `errStr` has been explicitly set.
  var hasErrStr: Bool {return _storage._errStr != nil}
  /// Clears the value of `errStr`. Subsequent reads from it will return its default value.
  mutating func clearErrStr() {_uniqueStorage()._errStr = nil}

  var internalMessage: OneOf_InternalMessage? {
    get {return _storage._internalMessage}
    set {_uniqueStorage()._internalMessage = newValue}
  }

  /// Auth
  var messAuthReq: PBCommon_AuthenticationReq {
    get {
      if case .messAuthReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_AuthenticationReq()
    }
    set {_uniqueStorage()._internalMessage = .messAuthReq(newValue)}
  }

  var messAuthAnswer: PBCommon_AuthenticationAnswer {
    get {
      if case .messAuthAnswer(let v)? = _storage._internalMessage {return v}
      return PBCommon_AuthenticationAnswer()
    }
    set {_uniqueStorage()._internalMessage = .messAuthAnswer(newValue)}
  }

  /// User data
  var messGetUserDataReq: PBCommon_GetUserDataReq {
    get {
      if case .messGetUserDataReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetUserDataReq()
    }
    set {_uniqueStorage()._internalMessage = .messGetUserDataReq(newValue)}
  }

  var messGetUserDataAnswer: PBCommon_GetUserDataAnswer {
    get {
      if case .messGetUserDataAnswer(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetUserDataAnswer()
    }
    set {_uniqueStorage()._internalMessage = .messGetUserDataAnswer(newValue)}
  }

  var messGetMasterUserDataReq: PBCommon_GetMasterUserDataReq {
    get {
      if case .messGetMasterUserDataReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetMasterUserDataReq()
    }
    set {_uniqueStorage()._internalMessage = .messGetMasterUserDataReq(newValue)}
  }

  var messGetMasterUserDataResp: PBCommon_GetMasterUserDataResp {
    get {
      if case .messGetMasterUserDataResp(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetMasterUserDataResp()
    }
    set {_uniqueStorage()._internalMessage = .messGetMasterUserDataResp(newValue)}
  }

  /// Messages
  var messSendChatMessageReq: PBCommon_SendChatMessageReq {
    get {
      if case .messSendChatMessageReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_SendChatMessageReq()
    }
    set {_uniqueStorage()._internalMessage = .messSendChatMessageReq(newValue)}
  }

  var messEditChatMessageReq: PBCommon_EditChatMessageReq {
    get {
      if case .messEditChatMessageReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_EditChatMessageReq()
    }
    set {_uniqueStorage()._internalMessage = .messEditChatMessageReq(newValue)}
  }

  var messNewChatMessageEvent: PBCommon_NewChatMessageEvent {
    get {
      if case .messNewChatMessageEvent(let v)? = _storage._internalMessage {return v}
      return PBCommon_NewChatMessageEvent()
    }
    set {_uniqueStorage()._internalMessage = .messNewChatMessageEvent(newValue)}
  }

  var messChatMessageChangedEvent: PBCommon_ChatMessageChangedEvent {
    get {
      if case .messChatMessageChangedEvent(let v)? = _storage._internalMessage {return v}
      return PBCommon_ChatMessageChangedEvent()
    }
    set {_uniqueStorage()._internalMessage = .messChatMessageChangedEvent(newValue)}
  }

  var messDeleteChatMessageReq: PBCommon_DeleteChatMessageReq {
    get {
      if case .messDeleteChatMessageReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_DeleteChatMessageReq()
    }
    set {_uniqueStorage()._internalMessage = .messDeleteChatMessageReq(newValue)}
  }

  var messChatMessageDeletedEvent: PBCommon_ChatMessageDeletedEvent {
    get {
      if case .messChatMessageDeletedEvent(let v)? = _storage._internalMessage {return v}
      return PBCommon_ChatMessageDeletedEvent()
    }
    set {_uniqueStorage()._internalMessage = .messChatMessageDeletedEvent(newValue)}
  }

  var messGetAllChatMessagesReq: PBCommon_GetAllChatMessagesReq {
    get {
      if case .messGetAllChatMessagesReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetAllChatMessagesReq()
    }
    set {_uniqueStorage()._internalMessage = .messGetAllChatMessagesReq(newValue)}
  }

  var messGetAllChatMessagesAnswer: PBCommon_GetAllChatMessagesAnswer {
    get {
      if case .messGetAllChatMessagesAnswer(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetAllChatMessagesAnswer()
    }
    set {_uniqueStorage()._internalMessage = .messGetAllChatMessagesAnswer(newValue)}
  }

  /// Push
  var messSubscribeToPushReq: PBCommon_SubscribeToPushReq {
    get {
      if case .messSubscribeToPushReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_SubscribeToPushReq()
    }
    set {_uniqueStorage()._internalMessage = .messSubscribeToPushReq(newValue)}
  }

  /// Chats
  var messGetChatListReq: PBCommon_GetChatListReq {
    get {
      if case .messGetChatListReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetChatListReq()
    }
    set {_uniqueStorage()._internalMessage = .messGetChatListReq(newValue)}
  }

  var messGetChatListResp: PBCommon_GetChatListResp {
    get {
      if case .messGetChatListResp(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetChatListResp()
    }
    set {_uniqueStorage()._internalMessage = .messGetChatListResp(newValue)}
  }

  var messGetUnreadInfoReq: PBCommon_GetUnreadInfoReq {
    get {
      if case .messGetUnreadInfoReq(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetUnreadInfoReq()
    }
    set {_uniqueStorage()._internalMessage = .messGetUnreadInfoReq(newValue)}
  }

  var messGetUnreadInfoResp: PBCommon_GetUnreadInfoResp {
    get {
      if case .messGetUnreadInfoResp(let v)? = _storage._internalMessage {return v}
      return PBCommon_GetUnreadInfoResp()
    }
    set {_uniqueStorage()._internalMessage = .messGetUnreadInfoResp(newValue)}
  }

  /// Other events
  var messReturnedMessageEvent: PBCommon_ReturnedMessageEvent {
    get {
      if case .messReturnedMessageEvent(let v)? = _storage._internalMessage {return v}
      return PBCommon_ReturnedMessageEvent()
    }
    set {_uniqueStorage()._internalMessage = .messReturnedMessageEvent(newValue)}
  }

  var messStandartAnswer: PBCommon_StandartAnswer {
    get {
      if case .messStandartAnswer(let v)? = _storage._internalMessage {return v}
      return PBCommon_StandartAnswer()
    }
    set {_uniqueStorage()._internalMessage = .messStandartAnswer(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_InternalMessage: Equatable {
    /// Auth
    case messAuthReq(PBCommon_AuthenticationReq)
    case messAuthAnswer(PBCommon_AuthenticationAnswer)
    /// User data
    case messGetUserDataReq(PBCommon_GetUserDataReq)
    case messGetUserDataAnswer(PBCommon_GetUserDataAnswer)
    case messGetMasterUserDataReq(PBCommon_GetMasterUserDataReq)
    case messGetMasterUserDataResp(PBCommon_GetMasterUserDataResp)
    /// Messages
    case messSendChatMessageReq(PBCommon_SendChatMessageReq)
    case messEditChatMessageReq(PBCommon_EditChatMessageReq)
    case messNewChatMessageEvent(PBCommon_NewChatMessageEvent)
    case messChatMessageChangedEvent(PBCommon_ChatMessageChangedEvent)
    case messDeleteChatMessageReq(PBCommon_DeleteChatMessageReq)
    case messChatMessageDeletedEvent(PBCommon_ChatMessageDeletedEvent)
    case messGetAllChatMessagesReq(PBCommon_GetAllChatMessagesReq)
    case messGetAllChatMessagesAnswer(PBCommon_GetAllChatMessagesAnswer)
    /// Push
    case messSubscribeToPushReq(PBCommon_SubscribeToPushReq)
    /// Chats
    case messGetChatListReq(PBCommon_GetChatListReq)
    case messGetChatListResp(PBCommon_GetChatListResp)
    case messGetUnreadInfoReq(PBCommon_GetUnreadInfoReq)
    case messGetUnreadInfoResp(PBCommon_GetUnreadInfoResp)
    /// Other events
    case messReturnedMessageEvent(PBCommon_ReturnedMessageEvent)
    case messStandartAnswer(PBCommon_StandartAnswer)

  #if !swift(>=4.1)
    static func ==(lhs: PBCommon_PBMessage.OneOf_InternalMessage, rhs: PBCommon_PBMessage.OneOf_InternalMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.messAuthReq, .messAuthReq): return {
        guard case .messAuthReq(let l) = lhs, case .messAuthReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messAuthAnswer, .messAuthAnswer): return {
        guard case .messAuthAnswer(let l) = lhs, case .messAuthAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetUserDataReq, .messGetUserDataReq): return {
        guard case .messGetUserDataReq(let l) = lhs, case .messGetUserDataReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetUserDataAnswer, .messGetUserDataAnswer): return {
        guard case .messGetUserDataAnswer(let l) = lhs, case .messGetUserDataAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetMasterUserDataReq, .messGetMasterUserDataReq): return {
        guard case .messGetMasterUserDataReq(let l) = lhs, case .messGetMasterUserDataReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetMasterUserDataResp, .messGetMasterUserDataResp): return {
        guard case .messGetMasterUserDataResp(let l) = lhs, case .messGetMasterUserDataResp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messSendChatMessageReq, .messSendChatMessageReq): return {
        guard case .messSendChatMessageReq(let l) = lhs, case .messSendChatMessageReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messEditChatMessageReq, .messEditChatMessageReq): return {
        guard case .messEditChatMessageReq(let l) = lhs, case .messEditChatMessageReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messNewChatMessageEvent, .messNewChatMessageEvent): return {
        guard case .messNewChatMessageEvent(let l) = lhs, case .messNewChatMessageEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messChatMessageChangedEvent, .messChatMessageChangedEvent): return {
        guard case .messChatMessageChangedEvent(let l) = lhs, case .messChatMessageChangedEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messDeleteChatMessageReq, .messDeleteChatMessageReq): return {
        guard case .messDeleteChatMessageReq(let l) = lhs, case .messDeleteChatMessageReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messChatMessageDeletedEvent, .messChatMessageDeletedEvent): return {
        guard case .messChatMessageDeletedEvent(let l) = lhs, case .messChatMessageDeletedEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetAllChatMessagesReq, .messGetAllChatMessagesReq): return {
        guard case .messGetAllChatMessagesReq(let l) = lhs, case .messGetAllChatMessagesReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetAllChatMessagesAnswer, .messGetAllChatMessagesAnswer): return {
        guard case .messGetAllChatMessagesAnswer(let l) = lhs, case .messGetAllChatMessagesAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messSubscribeToPushReq, .messSubscribeToPushReq): return {
        guard case .messSubscribeToPushReq(let l) = lhs, case .messSubscribeToPushReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetChatListReq, .messGetChatListReq): return {
        guard case .messGetChatListReq(let l) = lhs, case .messGetChatListReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetChatListResp, .messGetChatListResp): return {
        guard case .messGetChatListResp(let l) = lhs, case .messGetChatListResp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetUnreadInfoReq, .messGetUnreadInfoReq): return {
        guard case .messGetUnreadInfoReq(let l) = lhs, case .messGetUnreadInfoReq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messGetUnreadInfoResp, .messGetUnreadInfoResp): return {
        guard case .messGetUnreadInfoResp(let l) = lhs, case .messGetUnreadInfoResp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messReturnedMessageEvent, .messReturnedMessageEvent): return {
        guard case .messReturnedMessageEvent(let l) = lhs, case .messReturnedMessageEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messStandartAnswer, .messStandartAnswer): return {
        guard case .messStandartAnswer(let l) = lhs, case .messStandartAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///===========================================================================
///DATA
///=============================================================================
struct PBCommon_UserData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt32 = 0

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var age: UInt32 {
    get {return _age ?? 0}
    set {_age = newValue}
  }
  /// Returns true if `age` has been explicitly set.
  var hasAge: Bool {return self._age != nil}
  /// Clears the value of `age`. Subsequent reads from it will return its default value.
  mutating func clearAge() {self._age = nil}

  var gender: PBCommon_Gender {
    get {return _gender ?? .unknownGender}
    set {_gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  var hasGender: Bool {return self._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  mutating func clearGender() {self._gender = nil}

  var cityName: String {
    get {return _cityName ?? String()}
    set {_cityName = newValue}
  }
  /// Returns true if `cityName` has been explicitly set.
  var hasCityName: Bool {return self._cityName != nil}
  /// Clears the value of `cityName`. Subsequent reads from it will return its default value.
  mutating func clearCityName() {self._cityName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _age: UInt32? = nil
  fileprivate var _gender: PBCommon_Gender? = nil
  fileprivate var _cityName: String? = nil
}

/// TODO
struct PBCommon_PrivateUserData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBCommon_ChatMessageData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  var type: PBCommon_ChatMessageType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var fromUserID: UInt32 {
    get {return _storage._fromUserID}
    set {_uniqueStorage()._fromUserID = newValue}
  }

  var time: UInt32 {
    get {return _storage._time ?? 0}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  var toChatID: UInt32 {
    get {return _storage._toChatID ?? 0}
    set {_uniqueStorage()._toChatID = newValue}
  }
  /// Returns true if `toChatID` has been explicitly set.
  var hasToChatID: Bool {return _storage._toChatID != nil}
  /// Clears the value of `toChatID`. Subsequent reads from it will return its default value.
  mutating func clearToChatID() {_uniqueStorage()._toChatID = nil}

  var toUserID: UInt32 {
    get {return _storage._toUserID ?? 0}
    set {_uniqueStorage()._toUserID = newValue}
  }
  /// Returns true if `toUserID` has been explicitly set.
  var hasToUserID: Bool {return _storage._toUserID != nil}
  /// Clears the value of `toUserID`. Subsequent reads from it will return its default value.
  mutating func clearToUserID() {_uniqueStorage()._toUserID = nil}

  var text: String {
    get {return _storage._text ?? String()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {_uniqueStorage()._text = nil}

  var isEdited: Bool {
    get {return _storage._isEdited ?? false}
    set {_uniqueStorage()._isEdited = newValue}
  }
  /// Returns true if `isEdited` has been explicitly set.
  var hasIsEdited: Bool {return _storage._isEdited != nil}
  /// Clears the value of `isEdited`. Subsequent reads from it will return its default value.
  mutating func clearIsEdited() {_uniqueStorage()._isEdited = nil}

  var imageURL: String {
    get {return _storage._imageURL ?? String()}
    set {_uniqueStorage()._imageURL = newValue}
  }
  /// Returns true if `imageURL` has been explicitly set.
  var hasImageURL: Bool {return _storage._imageURL != nil}
  /// Clears the value of `imageURL`. Subsequent reads from it will return its default value.
  mutating func clearImageURL() {_uniqueStorage()._imageURL = nil}

  var aspectRatio: Float {
    get {return _storage._aspectRatio ?? 0}
    set {_uniqueStorage()._aspectRatio = newValue}
  }
  /// Returns true if `aspectRatio` has been explicitly set.
  var hasAspectRatio: Bool {return _storage._aspectRatio != nil}
  /// Clears the value of `aspectRatio`. Subsequent reads from it will return its default value.
  mutating func clearAspectRatio() {_uniqueStorage()._aspectRatio = nil}

  var repliedMessage: PBCommon_ChatMessageData {
    get {return _storage._repliedMessage ?? PBCommon_ChatMessageData()}
    set {_uniqueStorage()._repliedMessage = newValue}
  }
  /// Returns true if `repliedMessage` has been explicitly set.
  var hasRepliedMessage: Bool {return _storage._repliedMessage != nil}
  /// Clears the value of `repliedMessage`. Subsequent reads from it will return its default value.
  mutating func clearRepliedMessage() {_uniqueStorage()._repliedMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBCommon_ChatData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chatID: UInt32 = 0

  var title: String = String()

  var iconURL: String {
    get {return _iconURL ?? String()}
    set {_iconURL = newValue}
  }
  /// Returns true if `iconURL` has been explicitly set.
  var hasIconURL: Bool {return self._iconURL != nil}
  /// Clears the value of `iconURL`. Subsequent reads from it will return its default value.
  mutating func clearIconURL() {self._iconURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _iconURL: String? = nil
}

struct PBCommon_UnreadInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt32 {
    get {return _userID ?? 0}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  mutating func clearUserID() {self._userID = nil}

  var chatID: UInt32 {
    get {return _chatID ?? 0}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  mutating func clearChatID() {self._chatID = nil}

  var unreadCount: UInt32 {
    get {return _unreadCount ?? 0}
    set {_unreadCount = newValue}
  }
  /// Returns true if `unreadCount` has been explicitly set.
  var hasUnreadCount: Bool {return self._unreadCount != nil}
  /// Clears the value of `unreadCount`. Subsequent reads from it will return its default value.
  mutating func clearUnreadCount() {self._unreadCount = nil}

  var lastSeenMessageID: String {
    get {return _lastSeenMessageID ?? String()}
    set {_lastSeenMessageID = newValue}
  }
  /// Returns true if `lastSeenMessageID` has been explicitly set.
  var hasLastSeenMessageID: Bool {return self._lastSeenMessageID != nil}
  /// Clears the value of `lastSeenMessageID`. Subsequent reads from it will return its default value.
  mutating func clearLastSeenMessageID() {self._lastSeenMessageID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userID: UInt32? = nil
  fileprivate var _chatID: UInt32? = nil
  fileprivate var _unreadCount: UInt32? = nil
  fileprivate var _lastSeenMessageID: String? = nil
}

///===========================================================================
///REQUEST
///=============================================================================
struct PBCommon_SendChatMessageReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: PBCommon_ChatMessageType = .unknownType

  var fromUserID: UInt32 = 0

  var toChatID: UInt32 {
    get {return _toChatID ?? 0}
    set {_toChatID = newValue}
  }
  /// Returns true if `toChatID` has been explicitly set.
  var hasToChatID: Bool {return self._toChatID != nil}
  /// Clears the value of `toChatID`. Subsequent reads from it will return its default value.
  mutating func clearToChatID() {self._toChatID = nil}

  var toUserID: UInt32 {
    get {return _toUserID ?? 0}
    set {_toUserID = newValue}
  }
  /// Returns true if `toUserID` has been explicitly set.
  var hasToUserID: Bool {return self._toUserID != nil}
  /// Clears the value of `toUserID`. Subsequent reads from it will return its default value.
  mutating func clearToUserID() {self._toUserID = nil}

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var imageURL: String {
    get {return _imageURL ?? String()}
    set {_imageURL = newValue}
  }
  /// Returns true if `imageURL` has been explicitly set.
  var hasImageURL: Bool {return self._imageURL != nil}
  /// Clears the value of `imageURL`. Subsequent reads from it will return its default value.
  mutating func clearImageURL() {self._imageURL = nil}

  var aspectRatio: Float {
    get {return _aspectRatio ?? 0}
    set {_aspectRatio = newValue}
  }
  /// Returns true if `aspectRatio` has been explicitly set.
  var hasAspectRatio: Bool {return self._aspectRatio != nil}
  /// Clears the value of `aspectRatio`. Subsequent reads from it will return its default value.
  mutating func clearAspectRatio() {self._aspectRatio = nil}

  var repliedMessage: PBCommon_ChatMessageData {
    get {return _repliedMessage ?? PBCommon_ChatMessageData()}
    set {_repliedMessage = newValue}
  }
  /// Returns true if `repliedMessage` has been explicitly set.
  var hasRepliedMessage: Bool {return self._repliedMessage != nil}
  /// Clears the value of `repliedMessage`. Subsequent reads from it will return its default value.
  mutating func clearRepliedMessage() {self._repliedMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _toChatID: UInt32? = nil
  fileprivate var _toUserID: UInt32? = nil
  fileprivate var _text: String? = nil
  fileprivate var _imageURL: String? = nil
  fileprivate var _aspectRatio: Float? = nil
  fileprivate var _repliedMessage: PBCommon_ChatMessageData? = nil
}

struct PBCommon_EditChatMessageReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var originMessage: PBCommon_ChatMessageData {
    get {return _originMessage ?? PBCommon_ChatMessageData()}
    set {_originMessage = newValue}
  }
  /// Returns true if `originMessage` has been explicitly set.
  var hasOriginMessage: Bool {return self._originMessage != nil}
  /// Clears the value of `originMessage`. Subsequent reads from it will return its default value.
  mutating func clearOriginMessage() {self._originMessage = nil}

  var newText: String {
    get {return _newText ?? String()}
    set {_newText = newValue}
  }
  /// Returns true if `newText` has been explicitly set.
  var hasNewText: Bool {return self._newText != nil}
  /// Clears the value of `newText`. Subsequent reads from it will return its default value.
  mutating func clearNewText() {self._newText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _originMessage: PBCommon_ChatMessageData? = nil
  fileprivate var _newText: String? = nil
}

struct PBCommon_DeleteChatMessageReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var fromUserID: UInt32 = 0

  var toChatID: UInt32 {
    get {return _toChatID ?? 0}
    set {_toChatID = newValue}
  }
  /// Returns true if `toChatID` has been explicitly set.
  var hasToChatID: Bool {return self._toChatID != nil}
  /// Clears the value of `toChatID`. Subsequent reads from it will return its default value.
  mutating func clearToChatID() {self._toChatID = nil}

  var toUserID: UInt32 {
    get {return _toUserID ?? 0}
    set {_toUserID = newValue}
  }
  /// Returns true if `toUserID` has been explicitly set.
  var hasToUserID: Bool {return self._toUserID != nil}
  /// Clears the value of `toUserID`. Subsequent reads from it will return its default value.
  mutating func clearToUserID() {self._toUserID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _toChatID: UInt32? = nil
  fileprivate var _toUserID: UInt32? = nil
}

struct PBCommon_SubscribeToPushReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAllChatMessages
struct PBCommon_GetAllChatMessagesReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chatID: UInt32 {
    get {return _chatID ?? 0}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  mutating func clearChatID() {self._chatID = nil}

  var userID: UInt32 {
    get {return _userID ?? 0}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  mutating func clearUserID() {self._userID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chatID: UInt32? = nil
  fileprivate var _userID: UInt32? = nil
}

struct PBCommon_GetAllChatMessagesAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chatID: UInt32 {
    get {return _chatID ?? 0}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  mutating func clearChatID() {self._chatID = nil}

  var userID: UInt32 {
    get {return _userID ?? 0}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  mutating func clearUserID() {self._userID = nil}

  var messages: [PBCommon_ChatMessageData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chatID: UInt32? = nil
  fileprivate var _userID: UInt32? = nil
}

/// GetChatList
struct PBCommon_GetChatListReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBCommon_GetChatListResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chats: [PBCommon_ChatData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Authentication
struct PBCommon_AuthenticationReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt32 = 0

  var sessionKey: String = String()

  /// аутентификация во время запуска прила, а не разворачивания
  var isFirstAuthentication: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBCommon_AuthenticationAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt32 = 0

  var isRegistration: UInt32 = 0

  var sessionKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetUserData
struct PBCommon_GetUserDataReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var users: [UInt32] = []

  var fields: [PBCommon_UserDataField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBCommon_GetUserDataAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [PBCommon_UserData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBCommon_GetMasterUserDataReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fields: [PBCommon_UserDataField] = []

  var privateFields: [PBCommon_PrivateUserDataField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBCommon_GetMasterUserDataResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: PBCommon_UserData {
    get {return _data ?? PBCommon_UserData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var privateData: PBCommon_PrivateUserData {
    get {return _privateData ?? PBCommon_PrivateUserData()}
    set {_privateData = newValue}
  }
  /// Returns true if `privateData` has been explicitly set.
  var hasPrivateData: Bool {return self._privateData != nil}
  /// Clears the value of `privateData`. Subsequent reads from it will return its default value.
  mutating func clearPrivateData() {self._privateData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: PBCommon_UserData? = nil
  fileprivate var _privateData: PBCommon_PrivateUserData? = nil
}

/// Unread messages
struct PBCommon_GetUnreadInfoReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userIds: [UInt32] = []

  var chatIds: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBCommon_GetUnreadInfoResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: [PBCommon_UnreadInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///===========================================================================
///ANSWER
///=============================================================================
struct PBCommon_StandartAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///===========================================================================
///EVENTS
///=============================================================================
struct PBCommon_NewChatMessageEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chatMessage: PBCommon_ChatMessageData {
    get {return _chatMessage ?? PBCommon_ChatMessageData()}
    set {_chatMessage = newValue}
  }
  /// Returns true if `chatMessage` has been explicitly set.
  var hasChatMessage: Bool {return self._chatMessage != nil}
  /// Clears the value of `chatMessage`. Subsequent reads from it will return its default value.
  mutating func clearChatMessage() {self._chatMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chatMessage: PBCommon_ChatMessageData? = nil
}

struct PBCommon_ChatMessageChangedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var type: PBCommon_ChatMessageType = .unknownType

  var toChatID: UInt32 {
    get {return _toChatID ?? 0}
    set {_toChatID = newValue}
  }
  /// Returns true if `toChatID` has been explicitly set.
  var hasToChatID: Bool {return self._toChatID != nil}
  /// Clears the value of `toChatID`. Subsequent reads from it will return its default value.
  mutating func clearToChatID() {self._toChatID = nil}

  var toUserID: UInt32 {
    get {return _toUserID ?? 0}
    set {_toUserID = newValue}
  }
  /// Returns true if `toUserID` has been explicitly set.
  var hasToUserID: Bool {return self._toUserID != nil}
  /// Clears the value of `toUserID`. Subsequent reads from it will return its default value.
  mutating func clearToUserID() {self._toUserID = nil}

  var newText: String {
    get {return _newText ?? String()}
    set {_newText = newValue}
  }
  /// Returns true if `newText` has been explicitly set.
  var hasNewText: Bool {return self._newText != nil}
  /// Clears the value of `newText`. Subsequent reads from it will return its default value.
  mutating func clearNewText() {self._newText = nil}

  var isEdited: Bool {
    get {return _isEdited ?? false}
    set {_isEdited = newValue}
  }
  /// Returns true if `isEdited` has been explicitly set.
  var hasIsEdited: Bool {return self._isEdited != nil}
  /// Clears the value of `isEdited`. Subsequent reads from it will return its default value.
  mutating func clearIsEdited() {self._isEdited = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _toChatID: UInt32? = nil
  fileprivate var _toUserID: UInt32? = nil
  fileprivate var _newText: String? = nil
  fileprivate var _isEdited: Bool? = nil
}

struct PBCommon_ChatMessageDeletedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var toChatID: UInt32 {
    get {return _toChatID ?? 0}
    set {_toChatID = newValue}
  }
  /// Returns true if `toChatID` has been explicitly set.
  var hasToChatID: Bool {return self._toChatID != nil}
  /// Clears the value of `toChatID`. Subsequent reads from it will return its default value.
  mutating func clearToChatID() {self._toChatID = nil}

  var toUserID: UInt32 {
    get {return _toUserID ?? 0}
    set {_toUserID = newValue}
  }
  /// Returns true if `toUserID` has been explicitly set.
  var hasToUserID: Bool {return self._toUserID != nil}
  /// Clears the value of `toUserID`. Subsequent reads from it will return its default value.
  mutating func clearToUserID() {self._toUserID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _toChatID: UInt32? = nil
  fileprivate var _toUserID: UInt32? = nil
}

struct PBCommon_ReturnedMessageEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reasonOfReturn: PBCommon_ReturnReason {
    get {return _storage._reasonOfReturn}
    set {_uniqueStorage()._reasonOfReturn = newValue}
  }

  var returnedMessage: PBCommon_PBMessage {
    get {return _storage._returnedMessage ?? PBCommon_PBMessage()}
    set {_uniqueStorage()._returnedMessage = newValue}
  }
  /// Returns true if `returnedMessage` has been explicitly set.
  var hasReturnedMessage: Bool {return _storage._returnedMessage != nil}
  /// Clears the value of `returnedMessage`. Subsequent reads from it will return its default value.
  mutating func clearReturnedMessage() {_uniqueStorage()._returnedMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PBCommon_Gender: @unchecked Sendable {}
extension PBCommon_ChatMessageType: @unchecked Sendable {}
extension PBCommon_UserDataField: @unchecked Sendable {}
extension PBCommon_PrivateUserDataField: @unchecked Sendable {}
extension PBCommon_ReturnReason: @unchecked Sendable {}
extension PBCommon_PBMessage: @unchecked Sendable {}
extension PBCommon_PBMessage.OneOf_InternalMessage: @unchecked Sendable {}
extension PBCommon_UserData: @unchecked Sendable {}
extension PBCommon_PrivateUserData: @unchecked Sendable {}
extension PBCommon_ChatMessageData: @unchecked Sendable {}
extension PBCommon_ChatData: @unchecked Sendable {}
extension PBCommon_UnreadInfo: @unchecked Sendable {}
extension PBCommon_SendChatMessageReq: @unchecked Sendable {}
extension PBCommon_EditChatMessageReq: @unchecked Sendable {}
extension PBCommon_DeleteChatMessageReq: @unchecked Sendable {}
extension PBCommon_SubscribeToPushReq: @unchecked Sendable {}
extension PBCommon_GetAllChatMessagesReq: @unchecked Sendable {}
extension PBCommon_GetAllChatMessagesAnswer: @unchecked Sendable {}
extension PBCommon_GetChatListReq: @unchecked Sendable {}
extension PBCommon_GetChatListResp: @unchecked Sendable {}
extension PBCommon_AuthenticationReq: @unchecked Sendable {}
extension PBCommon_AuthenticationAnswer: @unchecked Sendable {}
extension PBCommon_GetUserDataReq: @unchecked Sendable {}
extension PBCommon_GetUserDataAnswer: @unchecked Sendable {}
extension PBCommon_GetMasterUserDataReq: @unchecked Sendable {}
extension PBCommon_GetMasterUserDataResp: @unchecked Sendable {}
extension PBCommon_GetUnreadInfoReq: @unchecked Sendable {}
extension PBCommon_GetUnreadInfoResp: @unchecked Sendable {}
extension PBCommon_StandartAnswer: @unchecked Sendable {}
extension PBCommon_NewChatMessageEvent: @unchecked Sendable {}
extension PBCommon_ChatMessageChangedEvent: @unchecked Sendable {}
extension PBCommon_ChatMessageDeletedEvent: @unchecked Sendable {}
extension PBCommon_ReturnedMessageEvent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "PBCommon"

extension PBCommon_Gender: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownGender"),
    1: .same(proto: "Male"),
    2: .same(proto: "Female"),
    3: .same(proto: "Other"),
  ]
}

extension PBCommon_ChatMessageType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownType"),
    1: .same(proto: "Text"),
    2: .same(proto: "Image"),
    3: .same(proto: "GIF"),
  ]
}

extension PBCommon_UserDataField: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FieldUserID"),
    1: .same(proto: "FieldName"),
    2: .same(proto: "FieldAge"),
    3: .same(proto: "FieldGender"),
    4: .same(proto: "FieldCityName"),
  ]
}

extension PBCommon_PrivateUserDataField: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FieldPhoneNumber"),
  ]
}

extension PBCommon_ReturnReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AuthenticationNeeded"),
  ]
}

extension PBCommon_PBMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PBMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RowID"),
    2: .same(proto: "ErrID"),
    3: .same(proto: "ErrStr"),
    20: .same(proto: "MessAuthReq"),
    21: .same(proto: "MessAuthAnswer"),
    50: .same(proto: "MessGetUserDataReq"),
    51: .same(proto: "MessGetUserDataAnswer"),
    52: .same(proto: "MessGetMasterUserDataReq"),
    53: .same(proto: "MessGetMasterUserDataResp"),
    100: .same(proto: "MessSendChatMessageReq"),
    101: .same(proto: "MessEditChatMessageReq"),
    102: .same(proto: "MessNewChatMessageEvent"),
    103: .same(proto: "MessChatMessageChangedEvent"),
    104: .same(proto: "MessDeleteChatMessageReq"),
    105: .same(proto: "MessChatMessageDeletedEvent"),
    200: .same(proto: "MessGetAllChatMessagesReq"),
    201: .same(proto: "MessGetAllChatMessagesAnswer"),
    250: .same(proto: "MessSubscribeToPushReq"),
    300: .same(proto: "MessGetChatListReq"),
    301: .same(proto: "MessGetChatListResp"),
    302: .same(proto: "MessGetUnreadInfoReq"),
    303: .same(proto: "MessGetUnreadInfoResp"),
    1999: .same(proto: "MessReturnedMessageEvent"),
    2000: .same(proto: "MessStandartAnswer"),
  ]

  fileprivate class _StorageClass {
    var _rowID: UInt32 = 0
    var _errID: UInt32? = nil
    var _errStr: String? = nil
    var _internalMessage: PBCommon_PBMessage.OneOf_InternalMessage?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rowID = source._rowID
      _errID = source._errID
      _errStr = source._errStr
      _internalMessage = source._internalMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._rowID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._errID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._errStr) }()
        case 20: try {
          var v: PBCommon_AuthenticationReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messAuthReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messAuthReq(v)
          }
        }()
        case 21: try {
          var v: PBCommon_AuthenticationAnswer?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messAuthAnswer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messAuthAnswer(v)
          }
        }()
        case 50: try {
          var v: PBCommon_GetUserDataReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetUserDataReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetUserDataReq(v)
          }
        }()
        case 51: try {
          var v: PBCommon_GetUserDataAnswer?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetUserDataAnswer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetUserDataAnswer(v)
          }
        }()
        case 52: try {
          var v: PBCommon_GetMasterUserDataReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetMasterUserDataReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetMasterUserDataReq(v)
          }
        }()
        case 53: try {
          var v: PBCommon_GetMasterUserDataResp?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetMasterUserDataResp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetMasterUserDataResp(v)
          }
        }()
        case 100: try {
          var v: PBCommon_SendChatMessageReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messSendChatMessageReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messSendChatMessageReq(v)
          }
        }()
        case 101: try {
          var v: PBCommon_EditChatMessageReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messEditChatMessageReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messEditChatMessageReq(v)
          }
        }()
        case 102: try {
          var v: PBCommon_NewChatMessageEvent?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messNewChatMessageEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messNewChatMessageEvent(v)
          }
        }()
        case 103: try {
          var v: PBCommon_ChatMessageChangedEvent?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messChatMessageChangedEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messChatMessageChangedEvent(v)
          }
        }()
        case 104: try {
          var v: PBCommon_DeleteChatMessageReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messDeleteChatMessageReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messDeleteChatMessageReq(v)
          }
        }()
        case 105: try {
          var v: PBCommon_ChatMessageDeletedEvent?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messChatMessageDeletedEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messChatMessageDeletedEvent(v)
          }
        }()
        case 200: try {
          var v: PBCommon_GetAllChatMessagesReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetAllChatMessagesReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetAllChatMessagesReq(v)
          }
        }()
        case 201: try {
          var v: PBCommon_GetAllChatMessagesAnswer?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetAllChatMessagesAnswer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetAllChatMessagesAnswer(v)
          }
        }()
        case 250: try {
          var v: PBCommon_SubscribeToPushReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messSubscribeToPushReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messSubscribeToPushReq(v)
          }
        }()
        case 300: try {
          var v: PBCommon_GetChatListReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetChatListReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetChatListReq(v)
          }
        }()
        case 301: try {
          var v: PBCommon_GetChatListResp?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetChatListResp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetChatListResp(v)
          }
        }()
        case 302: try {
          var v: PBCommon_GetUnreadInfoReq?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetUnreadInfoReq(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetUnreadInfoReq(v)
          }
        }()
        case 303: try {
          var v: PBCommon_GetUnreadInfoResp?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messGetUnreadInfoResp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messGetUnreadInfoResp(v)
          }
        }()
        case 1999: try {
          var v: PBCommon_ReturnedMessageEvent?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messReturnedMessageEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messReturnedMessageEvent(v)
          }
        }()
        case 2000: try {
          var v: PBCommon_StandartAnswer?
          var hadOneofValue = false
          if let current = _storage._internalMessage {
            hadOneofValue = true
            if case .messStandartAnswer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._internalMessage = .messStandartAnswer(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._rowID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rowID, fieldNumber: 1)
      }
      try { if let v = _storage._errID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._errStr {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      switch _storage._internalMessage {
      case .messAuthReq?: try {
        guard case .messAuthReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .messAuthAnswer?: try {
        guard case .messAuthAnswer(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .messGetUserDataReq?: try {
        guard case .messGetUserDataReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .messGetUserDataAnswer?: try {
        guard case .messGetUserDataAnswer(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .messGetMasterUserDataReq?: try {
        guard case .messGetMasterUserDataReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .messGetMasterUserDataResp?: try {
        guard case .messGetMasterUserDataResp(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .messSendChatMessageReq?: try {
        guard case .messSendChatMessageReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      }()
      case .messEditChatMessageReq?: try {
        guard case .messEditChatMessageReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      }()
      case .messNewChatMessageEvent?: try {
        guard case .messNewChatMessageEvent(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      }()
      case .messChatMessageChangedEvent?: try {
        guard case .messChatMessageChangedEvent(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      }()
      case .messDeleteChatMessageReq?: try {
        guard case .messDeleteChatMessageReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      }()
      case .messChatMessageDeletedEvent?: try {
        guard case .messChatMessageDeletedEvent(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      }()
      case .messGetAllChatMessagesReq?: try {
        guard case .messGetAllChatMessagesReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
      }()
      case .messGetAllChatMessagesAnswer?: try {
        guard case .messGetAllChatMessagesAnswer(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
      }()
      case .messSubscribeToPushReq?: try {
        guard case .messSubscribeToPushReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 250)
      }()
      case .messGetChatListReq?: try {
        guard case .messGetChatListReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 300)
      }()
      case .messGetChatListResp?: try {
        guard case .messGetChatListResp(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
      }()
      case .messGetUnreadInfoReq?: try {
        guard case .messGetUnreadInfoReq(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 302)
      }()
      case .messGetUnreadInfoResp?: try {
        guard case .messGetUnreadInfoResp(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 303)
      }()
      case .messReturnedMessageEvent?: try {
        guard case .messReturnedMessageEvent(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1999)
      }()
      case .messStandartAnswer?: try {
        guard case .messStandartAnswer(let v)? = _storage._internalMessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2000)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_PBMessage, rhs: PBCommon_PBMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rowID != rhs_storage._rowID {return false}
        if _storage._errID != rhs_storage._errID {return false}
        if _storage._errStr != rhs_storage._errStr {return false}
        if _storage._internalMessage != rhs_storage._internalMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_UserData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserID"),
    2: .same(proto: "Name"),
    3: .same(proto: "Age"),
    4: .same(proto: "Gender"),
    5: .same(proto: "CityName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._age) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._gender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._cityName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularUInt32Field(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._age {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gender {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cityName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_UserData, rhs: PBCommon_UserData) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._age != rhs._age {return false}
    if lhs._gender != rhs._gender {return false}
    if lhs._cityName != rhs._cityName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_PrivateUserData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrivateUserData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_PrivateUserData, rhs: PBCommon_PrivateUserData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_ChatMessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatMessageData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageID"),
    2: .same(proto: "Type"),
    3: .same(proto: "FromUserID"),
    4: .same(proto: "Time"),
    5: .same(proto: "ToChatID"),
    6: .same(proto: "ToUserID"),
    7: .same(proto: "Text"),
    8: .same(proto: "IsEdited"),
    9: .same(proto: "ImageURL"),
    10: .same(proto: "AspectRatio"),
    11: .same(proto: "RepliedMessage"),
  ]

  fileprivate class _StorageClass {
    var _messageID: String = String()
    var _type: PBCommon_ChatMessageType = .unknownType
    var _fromUserID: UInt32 = 0
    var _time: UInt32? = nil
    var _toChatID: UInt32? = nil
    var _toUserID: UInt32? = nil
    var _text: String? = nil
    var _isEdited: Bool? = nil
    var _imageURL: String? = nil
    var _aspectRatio: Float? = nil
    var _repliedMessage: PBCommon_ChatMessageData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageID = source._messageID
      _type = source._type
      _fromUserID = source._fromUserID
      _time = source._time
      _toChatID = source._toChatID
      _toUserID = source._toUserID
      _text = source._text
      _isEdited = source._isEdited
      _imageURL = source._imageURL
      _aspectRatio = source._aspectRatio
      _repliedMessage = source._repliedMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._messageID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._fromUserID) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._toChatID) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._toUserID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isEdited) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._imageURL) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._aspectRatio) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._repliedMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._messageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageID, fieldNumber: 1)
      }
      if _storage._type != .unknownType {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._fromUserID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fromUserID, fieldNumber: 3)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._toChatID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._toUserID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._text {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._isEdited {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._imageURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._aspectRatio {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._repliedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_ChatMessageData, rhs: PBCommon_ChatMessageData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._fromUserID != rhs_storage._fromUserID {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._toChatID != rhs_storage._toChatID {return false}
        if _storage._toUserID != rhs_storage._toUserID {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._isEdited != rhs_storage._isEdited {return false}
        if _storage._imageURL != rhs_storage._imageURL {return false}
        if _storage._aspectRatio != rhs_storage._aspectRatio {return false}
        if _storage._repliedMessage != rhs_storage._repliedMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_ChatData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatID"),
    2: .same(proto: "Title"),
    3: .same(proto: "IconURL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._iconURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.chatID != 0 {
      try visitor.visitSingularUInt32Field(value: self.chatID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try { if let v = self._iconURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_ChatData, rhs: PBCommon_ChatData) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.title != rhs.title {return false}
    if lhs._iconURL != rhs._iconURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_UnreadInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnreadInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserID"),
    2: .same(proto: "ChatID"),
    3: .same(proto: "UnreadCount"),
    4: .same(proto: "LastSeenMessageID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._userID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._chatID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._unreadCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._lastSeenMessageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._chatID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._unreadCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lastSeenMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_UnreadInfo, rhs: PBCommon_UnreadInfo) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs._chatID != rhs._chatID {return false}
    if lhs._unreadCount != rhs._unreadCount {return false}
    if lhs._lastSeenMessageID != rhs._lastSeenMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_SendChatMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendChatMessageReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "FromUserID"),
    3: .same(proto: "ToChatID"),
    4: .same(proto: "ToUserID"),
    5: .same(proto: "Text"),
    6: .same(proto: "ImageURL"),
    7: .same(proto: "AspectRatio"),
    8: .same(proto: "RepliedMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.fromUserID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._toChatID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._toUserID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._imageURL) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._aspectRatio) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._repliedMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.fromUserID != 0 {
      try visitor.visitSingularUInt32Field(value: self.fromUserID, fieldNumber: 2)
    }
    try { if let v = self._toChatID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._toUserID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._imageURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._aspectRatio {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._repliedMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_SendChatMessageReq, rhs: PBCommon_SendChatMessageReq) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.fromUserID != rhs.fromUserID {return false}
    if lhs._toChatID != rhs._toChatID {return false}
    if lhs._toUserID != rhs._toUserID {return false}
    if lhs._text != rhs._text {return false}
    if lhs._imageURL != rhs._imageURL {return false}
    if lhs._aspectRatio != rhs._aspectRatio {return false}
    if lhs._repliedMessage != rhs._repliedMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_EditChatMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EditChatMessageReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OriginMessage"),
    2: .same(proto: "NewText"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originMessage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._originMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_EditChatMessageReq, rhs: PBCommon_EditChatMessageReq) -> Bool {
    if lhs._originMessage != rhs._originMessage {return false}
    if lhs._newText != rhs._newText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_DeleteChatMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteChatMessageReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageID"),
    2: .same(proto: "FromUserID"),
    3: .same(proto: "ToChatID"),
    4: .same(proto: "ToUserID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.fromUserID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._toChatID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._toUserID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if self.fromUserID != 0 {
      try visitor.visitSingularUInt32Field(value: self.fromUserID, fieldNumber: 2)
    }
    try { if let v = self._toChatID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._toUserID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_DeleteChatMessageReq, rhs: PBCommon_DeleteChatMessageReq) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.fromUserID != rhs.fromUserID {return false}
    if lhs._toChatID != rhs._toChatID {return false}
    if lhs._toUserID != rhs._toUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_SubscribeToPushReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeToPushReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_SubscribeToPushReq, rhs: PBCommon_SubscribeToPushReq) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetAllChatMessagesReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAllChatMessagesReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatID"),
    2: .same(proto: "UserID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetAllChatMessagesReq, rhs: PBCommon_GetAllChatMessagesReq) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetAllChatMessagesAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAllChatMessagesAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChatID"),
    2: .same(proto: "UserID"),
    3: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._chatID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._userID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetAllChatMessagesAnswer, rhs: PBCommon_GetAllChatMessagesAnswer) -> Bool {
    if lhs._chatID != rhs._chatID {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetChatListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChatListReq"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetChatListReq, rhs: PBCommon_GetChatListReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetChatListResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChatListResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetChatListResp, rhs: PBCommon_GetChatListResp) -> Bool {
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_AuthenticationReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserID"),
    2: .same(proto: "SessionKey"),
    3: .same(proto: "IsFirstAuthentication"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionKey) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isFirstAuthentication) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionKey, fieldNumber: 2)
    }
    if self.isFirstAuthentication != false {
      try visitor.visitSingularBoolField(value: self.isFirstAuthentication, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_AuthenticationReq, rhs: PBCommon_AuthenticationReq) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionKey != rhs.sessionKey {return false}
    if lhs.isFirstAuthentication != rhs.isFirstAuthentication {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_AuthenticationAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserID"),
    2: .same(proto: "IsRegistration"),
    3: .same(proto: "SessionKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.isRegistration) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt32Field(value: self.userID, fieldNumber: 1)
    }
    if self.isRegistration != 0 {
      try visitor.visitSingularUInt32Field(value: self.isRegistration, fieldNumber: 2)
    }
    if !self.sessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_AuthenticationAnswer, rhs: PBCommon_AuthenticationAnswer) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.isRegistration != rhs.isRegistration {return false}
    if lhs.sessionKey != rhs.sessionKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetUserDataReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserDataReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Users"),
    2: .same(proto: "Fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.users) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.users, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitPackedEnumField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetUserDataReq, rhs: PBCommon_GetUserDataReq) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetUserDataAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserDataAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetUserDataAnswer, rhs: PBCommon_GetUserDataAnswer) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetMasterUserDataReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMasterUserDataReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Fields"),
    2: .same(proto: "PrivateFields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.fields) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.privateFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitPackedEnumField(value: self.fields, fieldNumber: 1)
    }
    if !self.privateFields.isEmpty {
      try visitor.visitPackedEnumField(value: self.privateFields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetMasterUserDataReq, rhs: PBCommon_GetMasterUserDataReq) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.privateFields != rhs.privateFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetMasterUserDataResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMasterUserDataResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Data"),
    2: .same(proto: "PrivateData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._privateData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._privateData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetMasterUserDataResp, rhs: PBCommon_GetMasterUserDataResp) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._privateData != rhs._privateData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetUnreadInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUnreadInfoReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserIDs"),
    2: .same(proto: "ChatIDs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.userIds) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.chatIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.userIds, fieldNumber: 1)
    }
    if !self.chatIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.chatIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetUnreadInfoReq, rhs: PBCommon_GetUnreadInfoReq) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.chatIds != rhs.chatIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_GetUnreadInfoResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUnreadInfoResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.info.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.info, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_GetUnreadInfoResp, rhs: PBCommon_GetUnreadInfoResp) -> Bool {
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_StandartAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StandartAnswer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_StandartAnswer, rhs: PBCommon_StandartAnswer) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_NewChatMessageEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewChatMessageEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chatMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_NewChatMessageEvent, rhs: PBCommon_NewChatMessageEvent) -> Bool {
    if lhs._chatMessage != rhs._chatMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_ChatMessageChangedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatMessageChangedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageID"),
    2: .same(proto: "Type"),
    3: .same(proto: "ToChatID"),
    4: .same(proto: "ToUserID"),
    5: .same(proto: "NewText"),
    6: .same(proto: "IsEdited"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._toChatID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._toUserID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._newText) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isEdited) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._toChatID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._toUserID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._newText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isEdited {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_ChatMessageChangedEvent, rhs: PBCommon_ChatMessageChangedEvent) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.type != rhs.type {return false}
    if lhs._toChatID != rhs._toChatID {return false}
    if lhs._toUserID != rhs._toUserID {return false}
    if lhs._newText != rhs._newText {return false}
    if lhs._isEdited != rhs._isEdited {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_ChatMessageDeletedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatMessageDeletedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessageID"),
    2: .same(proto: "ToChatID"),
    3: .same(proto: "ToUserID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._toChatID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._toUserID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    try { if let v = self._toChatID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._toUserID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_ChatMessageDeletedEvent, rhs: PBCommon_ChatMessageDeletedEvent) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs._toChatID != rhs._toChatID {return false}
    if lhs._toUserID != rhs._toUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCommon_ReturnedMessageEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReturnedMessageEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ReasonOfReturn"),
    2: .same(proto: "ReturnedMessage"),
  ]

  fileprivate class _StorageClass {
    var _reasonOfReturn: PBCommon_ReturnReason = .authenticationNeeded
    var _returnedMessage: PBCommon_PBMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reasonOfReturn = source._reasonOfReturn
      _returnedMessage = source._returnedMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._reasonOfReturn) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._returnedMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._reasonOfReturn != .authenticationNeeded {
        try visitor.visitSingularEnumField(value: _storage._reasonOfReturn, fieldNumber: 1)
      }
      try { if let v = _storage._returnedMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCommon_ReturnedMessageEvent, rhs: PBCommon_ReturnedMessageEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reasonOfReturn != rhs_storage._reasonOfReturn {return false}
        if _storage._returnedMessage != rhs_storage._returnedMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
