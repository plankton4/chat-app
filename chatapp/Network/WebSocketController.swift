//
//  WebSocketController.swift
//  chatapp
//
//  Created by Dmitry Iv on 28.06.2022.
//

import Foundation
import Combine
import Network

let WS = WebSocketController.shared

class WebSocketController: NSObject {
    
    static let shared = WebSocketController()
    
    func sendPing(callback: ((Error?) -> Void)? = nil) {
        socket.sendPing { [weak self] error in
            if let error = error {
                NSLog("Sending PING failed: \(error)")
                self?.isConnected = false
                self?.connect()
            } else {
                //NSLog("PING SUCCESS üòä")
            }
            
            if let callback = callback {
                callback(error)
            }
        }
    }
    
    private let socketAddress = Config.serverPlace == .local ? SocketAddress.local : SocketAddress.remote
    private var socket: URLSessionWebSocketTask!
    private var session: URLSession!
    
    private var isConnected = false {
        didSet {
            if !isConnected {
                isAuthenticated = false
            }
        }
    }
    
    private var isAuthenticated = false {
        didSet {
            if isAuthenticated {
                //processRequestsQueue()
            }
        }
    }
    private var authenticationInProgress = false
    private var authenticationInProgressResetter: DispatchWorkItem?
    private var isFirstAuthentication = true
    // lastSuccessAuthenticationRowID ‚Äì —á—Ç–æ–± –∫–æ–≥–¥–∞ –Ω–∞–º –ø—Ä–∏—Ö–æ–¥–∏–ª ReturnedMessageEvent
    // —Å –ø—Ä–∏—á–∏–Ω–æ–π AuthenticationNeeded –º—ã –ø–æ–Ω–∏–º–∞–ª–∏ –ø—Ä–∏—à–µ–ª –æ–Ω –ø–æ–∑–∂–µ
    // —É—Å–ø–µ—à–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏–ª–∏ –¥–æ. –ï—Å–ª–∏ –¥–æ, —Ç–æ –º—ã –µ–≥–æ –∏–≥–Ω–æ—Ä–∏–º, —Ç.–∫. –º—ã —É–∂–µ
    // –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–ª–∏—Å—å –∏ –Ω–µ–∑–∞—á–µ–º —Å–±—Ä–∞—Å—ã–≤–∞—Ç—å –ø—Ä–∏–∑–Ω–∞–∫ isAuthenticated.
    // –ï—Å–ª–∏ –ø—Ä–∏—à–µ–ª —É–∂–µ –ø–æ—Å–ª–µ, –∑–Ω–∞—á–∏—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —Å–ª–µ—Ç–µ–ª–∞, –Ω—É–∂–Ω–æ –µ—â–µ —Ä–∞–∑ –ø—Ä–æ–π—Ç–∏
    // —Å–∫–∏–Ω—É–≤ –ø—Ä–∏–∑–Ω–∞–∫ isAuthenticated
    private var lastAuthenticationAnswerRowID: UInt32 = 0
    
    private var listenerForSocketOpened: Cancellable?
    
    // `reqQueue` ‚Äì —Å—é–¥–∞ —Å–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è –∑–∞–ø—Ä–æ—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏—Å—å –ø–æ –ø—Ä–∏—á–∏–Ω–µ
    // –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —Å–æ–∫–µ—Ç–æ–º, –Ω–µ–ø—Ä–æ–π–¥–µ–Ω–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏ —Ç.–¥.
    private var reqQueue: [PBCommon_PBMessage.OneOf_InternalMessage] = []
    
    // –∑–∞–ø—Ä–æ—Å—ã, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö –∫—Ä–∏—Ç–∏—á–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç, —Ç–∞–∫–∏–µ –∫–∞–∫ —Å–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤.
    // –µ—Å–ª–∏ –æ—Ç–≤–µ—Ç –¥–æ–ª–≥–æ –Ω–µ –ø–æ–ª—É—á–∞–µ–º, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –µ—â–µ —Ä–∞–∑
    // –∫–ª—é—á ‚Äì rowID
    private var importantRequests: [UInt32: PBCommon_PBMessage.OneOf_InternalMessage] = [:]
    private let importantRequestsQueue = DispatchQueue(label: "ImportantRequests")
    
    private let netStatusMonitorQueue = DispatchQueue(label: "NetStatusMonitor")
    private var nwPathMonitor: NWPathMonitor!
    private var connectedInterface: NWInterface.InterfaceType? = nil {
        didSet {
            if oldValue != nil && oldValue != connectedInterface {
                print("INTERFACE CHANGED!!!!")
                // –¥–∏—Å–∫–æ–Ω–Ω–µ–∫—Ç–∏–º —Å–æ–∫–µ—Ç, —Ç.–∫. –ø—Ä–∏ —Å–º–µ–Ω–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —Å–æ–∫–µ—Ç –±—É–¥–µ—Ç –≥–æ–≤–æ—Ä–∏—Ç—å,
                // —á—Ç–æ –≤—Å—ë –∑–±—Å, –Ω–æ –¥–æ –Ω–µ–≥–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–æ–π–¥–µ—Ç –≤ –∏—Ç–æ–≥–µ.
                disconnect()
                
                // –µ—Å–ª–∏ —Å–ø—É—Å—Ç—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è –¥–æ —Å–∏—Ö –ø–æ—Ä –Ω–µ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å,
                // –¥–µ–ª–∞–µ–º connect —Ä—É—á–∫–∞–º–∏
                DispatchQueue.main.asyncAfter(deadline: .now() + 3) { [weak self] in
                    if let weakSelf = self, !weakSelf.isConnected {
                        self?.connect()
                    }
                }
            }
        }
    }
    
    private var socketHandleQueue = DispatchQueue(label: "SocketHandleQueue")
    
    private let chatsHandler = ChatsNetworkHandler()
    
    override private init() {
        super.init()
        
        listenForNetConnectionStatus()
        listenForSocketOpening()
        
        self.session = URLSession(configuration: .default, delegate: self, delegateQueue: OperationQueue())
        self.connect()
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) { [weak self] in
            self?.continuePinging()
        }
    }
    
    private func connect() {
        self.socket = session.webSocketTask(with: URL(string: socketAddress)!)
        self.listen()
        self.socket.resume()
    }
    
    private func disconnect() {
        socket.cancel(with: .goingAway, reason: nil)
    }
    
    private func listen() {
        self.socket.receive { [weak self] result in
            guard let self = self else { return }
            
            switch result {
            case .failure(let error):
                print("SOCKET LISTEN ERROR \(error)")
                // TODO SHOW ALERT MAYBE
                return
            case .success(let message):
                switch message {
                case .data(let data):
                    self.socketHandleQueue.async {
                        self.handle(data)
                    }
                case .string(let str):
                    guard let data = str.data(using: .utf8) else { return }
                    self.socketHandleQueue.async {
                        self.handle(data)
                    }
                @unknown default:
                    break
                }
            }
            
            self.listen()
        }
    }
    
    private func listenForNetConnectionStatus() {
        nwPathMonitor = NWPathMonitor()
        nwPathMonitor.pathUpdateHandler = { path in
            if path.usesInterfaceType(.wifi) {
                self.connectedInterface = .wifi
            } else if path.usesInterfaceType(.cellular) {
                self.connectedInterface = .cellular
            } else if path.usesInterfaceType(.other) {
                //
            }
            
            if path.status == .satisfied {
                // –µ—Å—Ç—å –∏–Ω–µ—Ç
            } else {
                // –Ω–µ—Ç –∏–Ω–µ—Ç–∞
            }
        }
        nwPathMonitor.start(queue: netStatusMonitorQueue)
    }
    
    private func continuePinging() {
        self.sendPing(callback: { [weak self] _ in
            DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
                self?.continuePinging()
            }
        })
    }
    
    private func listenForSocketOpening() {
        listenerForSocketOpened = NotificationCenter.default
            .publisher(for: .nameSocketOpened)
            .sink { [weak self] _ in
                guard let weakSelf = self else { return }
                
                weakSelf.processRequestsQueue()
            }
    }
    
    private func processRequestsQueue() {
        while !reqQueue.isEmpty {
            let req = reqQueue.removeFirst()
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
                self.sendPbMessage(internalMess: req)
            }
        }
    }
    
    // MARK: RowID
    var lastRowID: UInt32 = 0
    private let rowIDQueue = DispatchQueue(label: "rowIDQueue", attributes: .concurrent)
    
    func getNewRowID() -> UInt32 {
        var newRowID: UInt32 = 0
        rowIDQueue.sync(flags: .barrier) {
            lastRowID += 1
            newRowID = lastRowID
        }
        return newRowID
    }
}

extension WebSocketController {
    
    enum SocketAddress {
        /// `ngrokAddress` temporary ngrok address, which i use for testing
        static let ngrokAddress = "wss://9894-81-163-104-163.ngrok.io"
        static let local = "ws://localhost:8048/ws"
        static let remote = ngrokAddress + "/ws" // WORK: replace ngrok on real server address
    }
}

/*===========================================================================
MARK: - Send methods
=============================================================================*/
extension WebSocketController {
     
    func authenticate(
        userId: UInt32 = AppGlobalState.userId,
        sessionKey: String = AppGlobalState.sessionKey)
    {
        if isAuthenticated || authenticationInProgress {
            return
        }
        
        var authReq = PBCommon_AuthenticationReq()
        authReq.userID = userId
        authReq.sessionKey = sessionKey
        authReq.isFirstAuthentication = self.isFirstAuthentication
        
        self.isFirstAuthentication = false
        authenticationInProgress = true
        authenticationInProgressResetter = DispatchWorkItem(block: {
            // –Ω–µ –ø–æ–ª—É—á–∏–ª–∏ –æ—Ç–≤–µ—Ç –≤ —Ç–µ—á–µ–Ω–∏–µ 10 —Å–µ–∫—É–Ω–¥ ‚Äì —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –æ–Ω –ø—Ä–æ—ë–±–∞–Ω
            self.authenticationInProgress = false
            
            if !self.isAuthenticated {
                self.authenticate()
            }
        })
        DispatchQueue.main.asyncAfter(
            deadline: .now() + 10,
            execute: authenticationInProgressResetter!)
        
        sendPbMessage(internalMess: .messAuthReq(authReq))
    }
    
    func subscribeToPush(token: String) {
        print("Subscribe to push \(token)")
        var req = PBCommon_SubscribeToPushReq()
        req.token = token
        sendPbMessage(internalMess: .messSubscribeToPushReq(req))
    }
    
    func getUserData(users: [UInt32], fields: [PBCommon_UserDataField]) {
        var req = PBCommon_GetUserDataReq()
        req.users = users
        req.fields = fields
        
        sendPbMessage(internalMess: .messGetUserDataReq(req))
    }
    
    func sendTextMessage(_ message: TextMessage, toDirect: Bool, roomID: UInt32) {
        //guard let id = userSocketId else { return }
        print("Send text message \(message)")
        
        if let originMessage = message.originMessage {
            // –∑–Ω–∞—á–∏—Ç –±—ã–ª–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
            var sendReq = PBCommon_EditChatMessageReq()
            
            var pbChatMessageData = PBCommon_ChatMessageData()
            pbChatMessageData.messageID = originMessage.id
            
            switch originMessage.type {
            case .text:
                pbChatMessageData.type = .text
            default:
                pbChatMessageData.type = .unknownType
            }
            
            pbChatMessageData.fromUserID = AppGlobalState.userId
            
            if toDirect {
                pbChatMessageData.toUserID = roomID
            } else {
                pbChatMessageData.toChatID = roomID
            }
            
            sendReq.originMessage = pbChatMessageData
            
            sendReq.newText = message.text
            sendPbMessage(internalMess: .messEditChatMessageReq(sendReq))
        } else {
            var sendReq = PBCommon_SendChatMessageReq()
            sendReq.type = .text
            sendReq.fromUserID = AppGlobalState.userId
            
            if toDirect {
                sendReq.toUserID = roomID
            } else {
                sendReq.toChatID = roomID
            }
            
            sendReq.text = message.text
            
            if let replyMessage = message.replyMessage {
                sendReq.repliedMessage = self.fillRepliedMessage(
                    replyMessage: replyMessage,
                    toDirect: toDirect,
                    roomID: roomID)
            }
            
            sendPbMessage(internalMess: .messSendChatMessageReq(sendReq))
        }
    }
    
    func sendChatPhotoMessage(_ message: PhotoMessage, toDirect: Bool, roomID: UInt32) {
        if let uiImage = message.uiImage {
            DispatchQueue.main.async {
                HttpManager.shared.getImageURLFromServerForUIImage(
                    uiImage: uiImage,
                    completionHandler: { result in
                        switch result {
                        case .success(let url):
                            var req = PBCommon_SendChatMessageReq()
                            req.type = .image
                            req.fromUserID = AppGlobalState.userId
                            
                            if toDirect {
                                req.toUserID = roomID
                            } else {
                                req.toChatID = roomID
                            }
                            req.imageURL = url
                            req.aspectRatio = message.aspectRatio
                            
                            if let replyMessage = message.replyMessage {
                                req.repliedMessage = self.fillRepliedMessage(
                                    replyMessage: replyMessage,
                                    toDirect: toDirect,
                                    roomID: roomID)
                            }
                            
                            self.sendPbMessage(internalMess: .messSendChatMessageReq(req))
                        case .failure(let error):
                            print("Error in sendChatPhotoMessage: \(error)")
                        }
                    }
                )
            }
        } else if let _ = message.photoUrl {
            // TODO
        }
    }
    
    func sendChatGIFMessage(_ message: GIFMessage, toDirect: Bool, roomID: UInt32) {
        var req = PBCommon_SendChatMessageReq()
        req.type = .gif
        req.fromUserID = AppGlobalState.userId
        
        if toDirect {
            req.toUserID = roomID
        } else {
            req.toChatID = roomID
        }
        req.imageURL = message.gifUrl
        
        if let replyMessage = message.replyMessage {
            req.repliedMessage = fillRepliedMessage(
                replyMessage: replyMessage,
                toDirect: toDirect,
                roomID: roomID)
        }

        self.sendPbMessage(internalMess: .messSendChatMessageReq(req))
    }
    
    func deleteChatMessage(message: Message, toDirect: Bool, roomID: UInt32) {
        var req = PBCommon_DeleteChatMessageReq()
        req.messageID = message.id
        req.fromUserID = AppGlobalState.userId
        
        if toDirect {
            req.toUserID = roomID
        } else {
            req.toChatID = roomID
        }
        
        self.sendPbMessage(internalMess: .messDeleteChatMessageReq(req))
    }
    
    func getAllChatMessages(userID: UInt32? = nil, chatID: UInt32? = nil) {
        print("GET ALL CHAT MESSAGES. User: \(String(describing: userID)), chat: \(String(describing: chatID))")
        
        var req = PBCommon_GetAllChatMessagesReq()
        if userID != nil {
            req.userID = userID!
        } else if chatID != nil {
            req.chatID = chatID!
        }
        
        sendPbMessage(internalMess: .messGetAllChatMessagesReq(req))
    }
    
    func getChatList() {
        print("GET CHAT LIST")
        
        let req = PBCommon_GetChatListReq()
        sendPbMessage(internalMess: .messGetChatListReq(req), isImportant: true)
    }
    
    func getUnreadInfo(userIDs: [UInt32] = [], chatIDs: [UInt32] = []) {
        var req = PBCommon_GetUnreadInfoReq()
        
        for userID in userIDs {
            req.userIds.append(userID)
        }
        
        for chatID in chatIDs {
            req.chatIds.append(chatID)
        }
        
        sendPbMessage(internalMess: .messGetUnreadInfoReq(req))
    }
    
    private func sendPbMessage(
        internalMess: PBCommon_PBMessage.OneOf_InternalMessage,
        isImportant: Bool = false)
    {
        guard isConnected else {
            reqQueue.append(internalMess)
            //NSLog("NOT CONNECTED!!! append \(reqQueue.count)")
            return
        }
        
        // –∫–æ–≥–¥–∞ –Ω–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω—ã, —Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ —Ç–æ–ª—å–∫–æ –∑–∞–ø—Ä–æ—Å messAuthReq
        if !isAuthenticated {
            if case .messAuthReq = internalMess {
                // do nothing
            } else {
                reqQueue.append(internalMess)

                if !authenticationInProgress {
                    authenticate()
                }
                //NSLog("NOT AUTHENTICATED!!! append \(reqQueue.count)")
                return
            }
        }
        
        var message = PBCommon_PBMessage()
        let rowID = getNewRowID()
        message.rowID = rowID
        message.internalMessage = internalMess
        
        do {
            let data: Data = try message.serializedData()
            print("Socket Send \(message)")
            self.socket.send(.data(data)) { [weak self] err in
                guard let self = self else { return }
                
                if err != nil {
                    print("Error when socket send \(err.debugDescription)")
                    self.reqQueue.append(internalMess)
                } else {
                    if isImportant {
                        switch internalMess {
                        // –¥—Ä—É–≥–∏–µ —Ç–∞–∫–∏–µ –∂–µ –≤—ã—Ç–∞—Å–∫–∏–≤–∞–µ–º –∏–∑ importantRequests —Ç.–∫. –Ω–µ –Ω—É–∂–Ω—ã.
                        // –Ω–æ, –Ω–µ –≤—Å–µ, –∞ —Ç–æ–ª—å–∫–æ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω—ã–µ, —Ç–∞–∫–∏–µ –∫–∞–∫ –∑–∞–ø—Ä–æ—Å —á–∞—Ç–æ–≤
                        case .messGetChatListReq:
                            for (rowID, request) in self.importantRequests {
                                if case .messGetChatListReq = request {
                                    self.importantRequests.removeValue(forKey: rowID)
                                }
                            }
                        default: break
                        }
                        
                        self.importantRequests[rowID] = internalMess
                        self.importantRequestsQueue.asyncAfter(deadline: .now() + 10) {
                            if let req = self.importantRequests[rowID] {
                                self.sendPbMessage(internalMess: req, isImportant: true)
                            }
                        }
                    }
                }
            }
        } catch {
            print("SOCKET SEND CATCH!!!, error: \(error)")
        }
    }
    
    private func fillRepliedMessage(
        replyMessage: Message,
        toDirect: Bool,
        roomID: UInt32) -> PBCommon_ChatMessageData
    {
        var pbRepliedMessageData = PBCommon_ChatMessageData()
        pbRepliedMessageData.messageID = replyMessage.id
        pbRepliedMessageData.fromUserID = replyMessage.userID
        
        if toDirect {
            pbRepliedMessageData.toUserID = roomID
        } else {
            pbRepliedMessageData.toChatID = roomID
        }
        
        return pbRepliedMessageData
    }
}

/*===========================================================================
MARK: - Receive methods
=============================================================================*/
extension WebSocketController {
    
    private func handle(_ data: Data) {
        //print("Handle DATA " + String(decoding: data, as: UTF8.self))
        
        guard let pbMess = try? PBCommon_PBMessage(serializedData: data) else {
            print("SOCKET ERROR! Error when try to deserialize.")
            return
        }
        guard let internalMess = pbMess.internalMessage else  {
            print("SOCKET ERROR! Error when try to get internalMess.")
            return
        }
        
        if let _ = importantRequests[pbMess.rowID] {
            importantRequests.removeValue(forKey: pbMess.rowID)
        }
        
        switch internalMess {
        // NewChatMessageEvent
        case .messNewChatMessageEvent(let event):
            print("WebSocket HANDLE PBMESS \(pbMess)")
            chatsHandler.handleNewChatMessageEvent(event.chatMessage)
        
        // ChatMessageChangedEvent
        case .messChatMessageChangedEvent(let event):
            print("WebSocket HANDLE PBMESS \(pbMess)")
            chatsHandler.handleChatMessageChangedEvent(event)
        
        // ChatMessageDeletedEvent
        case .messChatMessageDeletedEvent(let event):
            print("WebSocket HANDLE PBMESS \(pbMess)")
            chatsHandler.handleChatMessageDeletedEvent(event)
            
        // AuthAnswer
        case .messAuthAnswer(let authAnswer):
            print("WebSocket HANDLE PBMESS \(pbMess)")
            handleAuthAnswer(authAnswer, rowID: pbMess.rowID)
            
        // GetAllChatMessagesAnswer
        case .messGetAllChatMessagesAnswer(let answer):
            print("WebSocket HANDLE GetAllChatMessagesAnswer")
            chatsHandler.handleGetAllChatMessagesAnswer(
                userID: answer.hasUserID ? answer.userID : nil,
                chatID: answer.hasChatID ? answer.chatID : nil,
                messages: answer.messages)
            
        // GetChatListResp
        case .messGetChatListResp(let resp):
            chatsHandler.handleGetChatListResponse(resp)
            print("WebSocket HANDLE PBMESS \(pbMess)")
        
        // GetUnreadInfoResp
        case .messGetUnreadInfoResp(let resp):
            print("WebSocket HANDLE PBMESS \(pbMess)")
            
        // GetUserDataAnswer
        case .messGetUserDataAnswer(let answer):
            handleGetUserDataAnswer(answer)
            print("WebSocket HANDLE PBMESS \(pbMess)")
            
        // ReturnedMessageEvent
        case .messReturnedMessageEvent(let event):
            handleReturnedMessageEvent(event)
            print("WebSocket HANDLE PBMESS \(pbMess)")
            
        // default
        default:
            print("WebSocket DEFAULT CASE HANDLE PBMESS \(pbMess)")
            break
        }
    }
    
    private func handleAuthAnswer(
        _ authAnswer: PBCommon_AuthenticationAnswer,
        rowID: UInt32)
    {
        isAuthenticated = authAnswer.isRegistration == 0
        authenticationInProgress = false
        authenticationInProgressResetter?.cancel()
        lastAuthenticationAnswerRowID = rowID
        
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: .nameAuthAnswerReceived,
                object: nil,
                userInfo: ["Data": authAnswer])
        }
    }
    
    private func handleGetUserDataAnswer(_ answer: PBCommon_GetUserDataAnswer) {
        // WORK
    }
    
    private func handleReturnedMessageEvent(_ event: PBCommon_ReturnedMessageEvent) {
        switch event.reasonOfReturn {
        case .authenticationNeeded:
            if let internalMess = event.returnedMessage.internalMessage {
                reqQueue.append(internalMess)
            }
            
//            print("LAST AUTH \(lastAuthenticationAnswerRowID), RETURNED \(event.returnedMessage.rowID)")
            if lastAuthenticationAnswerRowID < event.returnedMessage.rowID {
                // –Ω—É–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ
                isAuthenticated = false
                authenticate()
            } else {
                // –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ AuthenticationAnswer –Ω–æ–≤–µ–µ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è,
                // –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
            }
        default: break
        }
    }
}

extension WebSocketController: URLSessionWebSocketDelegate {
    /// connection disconnected
    func urlSession(_ session: URLSession,
                    webSocketTask: URLSessionWebSocketTask,
                    didCloseWith closeCode: URLSessionWebSocketTask.CloseCode,
                    reason: Data?)
    {
        isConnected = false
        print("SOCKET urlSession CLOSED \(closeCode), reason \(String(describing: reason))")
    }

    // connection established
    func urlSession(_ session: URLSession,
                    webSocketTask: URLSessionWebSocketTask,
                    didOpenWithProtocol protocolStr: String?)
    {
        isConnected = true
        NSLog("SOCKET urlSession OPEN")
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: .nameSocketOpened,
                object: nil)
        }
    }
}
